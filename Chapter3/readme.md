* 클래스
> 함수를 포함할 수 있는 구조체
```
class 클래스이름
{
	접근제어지시자;
		멤버변수선언;
		멤버함수선언및정의;
```
예)
```
class	USERDATA
{
//접근제어지시자
public:
	//멤버 변수 선언
	int nAge;
	char szName[32];
	// 멤버 함수 선언 및 정의
	void	Print(void)
	{
		//nAge와 szName은 Print() 함수의 지역 변수가 아니다
		printf("%d, %s\n",nAge,szName);
	}
```
이런식으로 나타낼 수 있다.
> public : 멤버에 관한 모든외부 접근이 허용
> protected : 멤버에 관한 모든 외부 접근이 차단된다 . 단, 상속 관계에 있는 파생 클래스에서의 접근은 허용된다.
> private : 외부 접근뿐만 아니라 파생 클래스로부터의 접근까지 모두 차단된다. 클래스를 선언 할때 별도로 접근 제어 지시자를 기술하지 않으면 private로 간주
---
* 생성자와 소멸자
> 생성자와 소멸자는 클래스 객체가 생성 및 소멸될 때 *자동으로 호출되는 함수*이다.
> 소멸자 이름 앞에는 ~가 붙는다.
> 둘의 차이점은 생성자는 다중 정의할 수 있고 소멸자는 그럴 수 없다
```
클래스이름();
~클래스이름();
```
> 디폴트 생성자의 특징은 *클래스 제작자가 디폴트 생성자와 소멸자를 기술하지 않아도 컴파일러가 알아서 만들어 넣는다는 점*
> *c++에서는 전역 변수로 선언한 클래스의 생성자가 main()함수보다 먼저 호출된다.*
```
main() 함수가 호출되기 전에 생성자가 호출될 수 있다.
생성자는 다중 정의할 수 있다.
소멸자는 다중 정의할 수 없다.
main() 함수가 끝난 후에 소멸자가 호출될 수 있다.
생성자와 소멸자는 생략할 수 있으나 생략할 경우 컴파일러가 만들어 넣는다.
새로운 생성자를 만들면서 디폴드 생성자를 생략할 수 있다.
```
---
* new 와 delete
> 이 두가지를 이용해 클래스를 동적할당 할 수 있다.
```
CTest *pData = new CTest[3];
delete[] pData;
```
> 만약 배열로 생성한 객체를 배열로 삭제하지 않으면 첫번째 요소만 소멸하고 나머지는 메모리에 남는다.
---
* 메서드
> 사전적 의미 : 방법
> 클래스의 멤버 함수를 메서드라고 한다.
`static 반환 자료형 클래스이름 :: 함수이름( 매개변수)  const;`
---
* this 포인터
> 작성 중인 클래스의 실제 인스턴스에 대한 주소를 가르키는 포인터
* 상수형 메서드
> 맴버 변수에 읽기 접근은 가능하지만 쓰기는 허용되지 않는 메서드
> 선언방법 : 함수 원형 뒤에 const 예약어를 붙이면 된다.
