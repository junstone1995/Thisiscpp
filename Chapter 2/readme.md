# Chapter 2
*  디폴트 매개변수
```
int TestFunc(int nPram = 10)
{
	return nPram;
}
```
> 이런식으로 한다면
`TestFunc();`
> 이라고 입력하면 디폴트값인 10을 반환한다.
`TestFunc(20);`
> 이라고 입력하면 20을 반환한다.
 `반환자료형	함수이름(매개변수자료형이름 = 디폴트값);`
> 매개변수의 디폴트 값을 ‘선언’한 함수는 호출자 코드에서 실인수를 생략한 채 호출할 수 있다.
1. 매개변수의 디폴트 값은 반드시 오른쪽 매개변수부터 기술
2. 절대로 중간에 빼먹으면 안된다.
3. 짝이 맞지 않는 매개변수는 디폴트 값을 적용한다.
---
* 함수 다중 정의 (Overloading)
```
int Add(int a, int b, int c);
int Add(int a, int b);
double Add(double a, double b);
```
> 위와 같은 형식으로
> 매개변수나 함수 원형이 다르다면 c++은 다른 함수로 인식하기 때문에 다형성을 보장한다.
---
* 함수 템플릿
> 함수를 다중 정의하는 이유는 사용자의 편의성과 확장성을 얻을 수 있기 때문이다.
> 사용자를 편하게 해주자고 제작자는 같은일을 반복해야한다.
> 불필요한 코드가 생길수도 있고 논리적 오류가 생겼을때 일일이 수정해 줘야한다.
> 그래서 c++에서는 함수 템플릿을 사용하라고 권한다.
```
template <typename T>
반환형식    함수이름(매개변수)
{

}
```
---
* 인라인 함수
> 함수를 호출하면 스택 메모리 사용이 증가하고 매개변수 때문에 메모리 복사가 일어난다. -> 매크로를 사용하면 성능 향상을 할 수 있다.
> But , 매크로는 함수 x
> inline 함수 : 매크로의 장점과 함수의 장점을 두루 갖춘 함수
> 함수 원형 앞에 inline 만 붙이면 된다.
> *코드의 길이가 일정 수준 이상 길어지면 인라인 함수가 되는것은 바람직하지 않다.*
---
* 네임스페이스
> c++가 지원하는 각종 요소들(변수, 함수, 클래스 등)을 한 범주로 묶어주기 위한 문법
```
namespace 이름
{
	//네임스페이스 시작
	....

	//네임스페이스 끝
}
```
---
* using 선언
`using namespace 네임스페이스 이름`
---
* 식별자 검색 순서
> 전역함수의 경우
```
1. 현재 블록 범위
2. 현재 블록 범위를 포함하고 있는 상위 블록 범위
3. 가장 최근에 선언된 전역 변수나 함수
4. using 선언된 네임스페이스 혹은 전역 네임스페이스. 단 두 곳에 동일한 식별자가 존재할 경우 컴파일 오류 발생
```
> 클래스 메서드인 경우
```
1. 현재 블록 범위
2. 현재 블록 범위를 포함하고 있는 상위 블록 범위
3. 클래스 맴버
4. 부모 클래스의 맴버
5. 가장 최근에 선언된 전역 변수나 함수
6. 호출자 코드가 속한 네임스페이스의 상위 네임 스페이스
7. using 선언된 네임스페이스 혹은 전역 네임스페이스, 단 두곳에 동일한 식별자가 존재할 경우 컴파일 오류 발생
```
*Goole Style Guide* :이 책을 읽고 읽어보기
